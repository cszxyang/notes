### 1. olycode

#### 遇到什么样的并发问题？多条线程调用 System.out.println 会出现数据混乱的情况吗

不会，println 调用的是newLine() 方法，其中使用synchronized锁住 PrintStream 对象

为了避免客户端都执行这段代码，多线程竞争和等待同一把锁，去掉了 synchronized，使用ThreadLocal

#### 代理模式

##### 什么是动态代理

个人理解，动态代理就是通过某种技术，在运行时生成某个目标对象的代理对象，并通过一定形式的代码能够使得调用者对目标对象的方法调用透明地重定向到代理对象的方法上去。

##### JDK 代理和 cglib 的区别

JDK 代理：利用拦截器(拦截器必须实现 InvocationHanlder 加上反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用 InvokeHandler 来处理。

cglib：利用 ASM 开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。

区别

- **JDK 动态代理只能对实现了接口的类生成代理，而不能针对类。**
- **CGLIB 是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法，并覆盖其中方法实现增强，但是因为采用的是继承，所以该类或方法最好不要声明成 final，对于 final 类或方法，是无法继承的。**

##### 何时使用JDK还是 CGLIB？

- 如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP。
- 如果目标对象实现了接口，可以强制使用CGLIB实现AOP。
- 如果目标对象没有实现了接口，必须采用CGLIB库，Spring会自动在JDK动态代理和CGLIB之间转换。

#### 怎么操纵字节码的？

字节码文件具有明确的格式规范，如魔数、主版本号、次版本号、常量池、接口信息等结构及其所占用的字节数。

#### 怎么定义类加载器的？类加载过程是怎么样的？

类加载指的是虚拟机把描述类的数据从字节码文件加载待内存中，并对数据进行校验、转换解析和初始化，最终形成可被虚拟机直接使用的 Java 类型的过程。

![img](D:/projects/notes/面试总结/Java/assets/1551162638264.png)


包括了加载、验证、准备、解析、初始化这五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则是确定的，它在某些情况下，比如说，如果要实现动态绑定（如向上转型，动态绑定到子类的方法），解析会初始化阶段之后开始。

**加载**：查找并加载类的二进制数据，在这个阶段，虚拟机需要完成三件事情：

1. 通过一个类的全限定名来获取其定义的二进制字节流。

2. 根据Java虚拟机规范定义的字节码存储结构格式，将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的`java.lang.Class`对象，作为对方法区中这些数据的访问入口。

加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在内存中（并未明确规定在 Java 堆中，**对 HotSpot VM 而言，Class对象较为特殊，不存储在堆，而存储在方法区中**）创建一个`java.lang.Class`类的对象，这样便可以通过该对象访问方法区中的这些数据。

**验证**：为了确保字节码文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机的安全。 JVM 需要对字节码文件进行验证，验证的对象主要有：字节码文件格式、字节码中元数据定义、字节码中的指令逻辑以及符号引用。

**准备**：为类变量在`方法区`分配内存并`设置类变量默认初始值`。

**解析**：将常量池内的符号引用替换为直接引用，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行。符号引用是一组符号来描述目标，可以是任何字面量。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。

#### 什么是双亲委派模型？

#### ThreadLocal 怎么用的？

### 2. SHN 实习

#### 怎么解决慢查的？

首先这是一个搜索功能，正式服数据有 8 千多万，单表查询用了20 多秒。 首先，我定位到实际运行的 SQL 语句，通过 expain 获取其执行计划。

我看到那条 SQL 使用了 order by id DESC，即通查询按主键降序排列。

但执行计划显示其使用的是某个非主键字段的索引，而不是主键索引，同时执行计划中的 extra 列显示的是 using fielsort，即全表扫描，

通过查找资料分析，我认为是在 where 后面没有使用 主键 id 作为条件，虽然 where 后面有些字段是加了索引的，但是在后面降序排列时，由于没有指定 id 条件，所以 MySQL 分析器最后选择了全表扫描。

我的解决方法是改为按照一个加了索引非主键字段进行排序，这个字段是必传的，同时会出现在 where 中。