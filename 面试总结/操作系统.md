## 进程

### 进程与线程区别

**拥有资源：** 进程都是拥有资源的基本单位；而线程除了有一点运行时必不可少的资源不拥有系统资源，但线程可以访问其所属进程的资源

**调度方面：** 线程是独立调度的基本单位，进程内的线程的切换不会引起进程切换；进程间的线程切换会引起进程切换。

**系统开销：**

- **创建撤销的开销：** 因为在创建或撤销一个进程时，系统会为它分配或回收资源，如内存空间、I/O 设备等操作，系统所付出的开销远大于创建或撤销线程时的开销。
- **上下文切换：** 在进行进程切换时，涉及到整个当前进程 CPU 环境的保存及新调度到进程 CPU 环境的设置；而线程切换时，只需保存和设置少量寄存器内容，因此开销很小。

**通信方面：** 线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。

**协程** ：类似线程，协程也相对独立，有自己的上下文，但是其切换由自己控制，由当前协程切换到其他协程由当前协程来控制。

### 进程间通讯技术 IPC

1. **信号量（Semaphore）** ：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源，主要用于进程同步。具体分为整型信号量、记录型信号量、AND型信号量、信号量集等。

2. **匿名管道（pipe）** ：一种半双工的通信方式（即数据只能在一个方向上流动），不过现在也有一些支持全双工通信的管道。管道的原理是在两个进程间建立一个未命名的文件，一个进程往其中写数据，另一个进程从其中读数据，只能在具有亲缘关系的进程间使用。如父子进程和兄弟进程。通常，一个管道由一个进程创建，然后该进程调用 fork 函数，此后父、子进程之间就可应用该管道。Linux 下通过`int pipe(int fds[2]);`函数创建匿名管道。

3. **命名管道（FiFO）** ：有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。

   ```shell
   cmd1：
    	mkfifo my_pipe
    	ps -aux > my_pipe
   cmd2:
   	my_pipe > grep ssh
   ```

4. **消息队列（MessageQueue）** ：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

5. **共享内存（SharedMemory）** ：最快的进程通信方式，允许多个进程共享一个给定的存储区，这一段存储区可以被多个进程映射到自身的地址空间里面，一个进程向共享内存写入的信息，可以被其他共享该内存的进程读取，这样就实现了进程间的通信。

6. **套接字（Socket）** ：套接字指的是 IP 加端口，可用于网络中不同机器之间的进程间通信（accept、bind 等）

7. **信号 （Sinal）** ： 一种异步通信方式，信号可以在任何时候发送给某一进程，而无须知道该进程的状态。如果该进程并未处于执行状态，则该信号就由内核保存起来，直到该进程恢复执行并传递给它为止。如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程。信号事件有两个来源：

   - 硬件来源，例如按下了cltr+C，通常产生中断信号 Sigint
   - 软件来源，例如使用系统调用或者命令发出信号。最常用的发送信号的系统函数是kill、raise等

   一旦有信号产生，用户进程对信号产生的相应有三种方式：

   1. 执行默认操作，linux对每种信号都规定了默认操作。
   2. 捕捉信号，定义信号处理函数，当信号发生时，执行相应的处理函数。
   3. 忽略信号，当不希望接收到的信号对进程的执行产生影响，而让进程继续执行时，可以忽略该信号，即不对信号进程作任何处理。

   有两个信号是应用进程无法捕捉和忽略的，即SIGKILL和SEGSTOP，这是为了使系统管理员能在任何时候中断或结束某一特定的进程。

在Linux下可以用 ipcs 命令查看当前使用的共享内存、消息队列及信号量等信息进程通信信息

### 进程调度的策略

- 先来先服务（FCFS）：利用队列先进先出的特点实现，先请求CPU的进程先分配到CPU
- 最短作业优先调度算法（SIF）：平均等待时间最短，但难以知道下一个CPU区间长度
- 优先级调度算法：优先级越高越先分配到CPU，相同优先级先到先服务，存在的主要问题是：低优先级进程无穷等待CPU，会导致无穷阻塞或饥饿；解决方案：老化
- 时间片轮转调度算法：队列中没有进程被分配超过一个时间片的CPU时间，除非它是唯一可运行的进程。如果进程的CPU区间超过了一个时间片，那么该进程就被抢占并放回就绪队列。
- 多级队列调度算法：将就绪队列分成多个独立的队列，每个队列都有自己的调度算法，队列之间采用固定优先级抢占调度。其中，一个进程根据自身属性被永久地分配到一个队列中。
- 多级反馈队列调度算法：与多级队列调度算法相比，其允许进程在队列之间移动：若进程使用过多CPU时间，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生。

### 进程同步的方式

- 同步机制应该遵循的规则
  - 空闲让进：当无进程进入临界区，应允许一个进程访问临界资源
  - 忙则等待：当已有进程进入临界区访问临界资源，其他进程必须等待，以保证互斥访问
  - 有限等待：保证进程在有限时间内进入临界区
  - 让权等待：进程不能进入临界区时，应立即放弃CPU执行权

- 硬件方式
  - 关中断：计算机系统不响应中断，从而不引发调度，也就不会发生进程或线程的切换。
  - 利用 Test-and-Set 指令或 Swap 指令实现进程互斥
- 软件方式
  - 信号量：
    - 整型信号量：用一个整型变量 S 表示资源数目 ，通过两个原子性的PV操作对该信号量进行修改。当 S<=0 时，进程将会不停等待，违背让权等待规则。
    - 记录型信号量：用结构体表示，其中除了表示资源数目的变量外，增加一个指针变量变量指向一个阻塞队列，用于链接所有等待该资源的进程，当资源数目小于等于0时，正在等待该资源的进程将被添加到阻塞队列中，从而实现让权等待，当有一个资源被释放时，阻塞队列中的第一个进程将被唤醒。
    - AND 信号量：将进程需要的所有资源一次性全部分配给进程，待进程使用完后再一起释放，只要有一个资源未能分配给进程，其他有可能为之分配的资源也不会分配给它，
    - 信号量集： 通过一次PV操作尽可以对各种不同的资源的数目进行N个单位的申请和释放，
  - 管程：将表示共享资源的数据结构和对其操作封装成管程，每次仅有一个进程进入管程，执行管程内的操作，从而实现进程的互斥。管程内使用PV操作实现对共享变量的获取和释放。
  - 使用同步通信原语：
    - 当一个进程调用一个send原语时，在消息开始发送后便处于阻塞状态，直至消息完全发送完毕，send原语的后继语句才能继续执行。
    - 当一个进程调用一个receive原语时，并不立即返回控制，而是等到把消息实际接收下来，并把它放入指定的接收区，才返回控制，继续执行该原语的后继指令。在这段时间它一直处于阻塞状态。

### 线程同步的方式

互斥量 Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问

信号量 Semphare：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量

事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作

### 死锁

#### 死锁的概念

如果一组进程中的每一个进程都在等待由该组进程中的其他进程才能引发的事件，那么该组进程是死锁的。

#### 死锁产生的四个必要条件

- 互斥：进程所分配的到的资源是临界资源，需要互斥访问
- 请求和保持：进程已经持有了至少一个资源，同时又提出新的资源请求
- 不可抢占：进程所获得的资源在未使用完前不能被抢占
- 循环等待：在发生死锁时，必然存在一条进程-资源的循环链

解决死锁的基本方法主要有预防死锁、避免死锁、检测死锁、解除死锁 、鸵鸟策略等。

#### 死锁的预防

死锁预防的基本思想是只要确保死锁发生的四个必要条件中至少有一个不成立，就能预防死锁的发生，具体方法：

- 资源静态分配法：资源全分配全释放 （打破占有并保持）
- 资源可剥夺法：新申请不能满足则释放已获得资源 （打破不可抢占）
- 资源有序分配法：为资源编号，申请时需按编号进行（打破循环等待）

####  死锁避免

防止进入不安全状态，可以使用银行家算法，在找到一个安全分配资源的方案序列前提下，动态地分配资源。

#### 死锁解除

- 剥夺资源
- 进程回退
- 撤销进程

## 内存

### 内存可变式分区分配算法 

- 首次适应：符合大小要求即分配
- 循环首次适应：从上次分区的下一分区起循环找，找到符合大小要求即分配
- 最佳适应：在空闲区表中以空闲区长度按**从小到大**排列
- 最坏适应：在空闲区表中以空闲区长度按**从大到小**排列



### 分页和分段有什么区别

- 目的不同：分页是由于系统管理的需要而不是用户的需要，它是信息的物理单位；分段的目的是为了能更好地满足用户的需要，它是信息的逻辑单位，它含有一组其意义相对完整的信息；
- 大小不同：页的大小固定且由系统决定，而段的长度却不固定，由其所完成的功能决定；
- 地址空间不同： 段向用户提供二维地址空间；页向用户提供的是一维地址空间；
- 信息共享：段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制；
- 内存碎片：页式存储管理的优点是没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）；而段式管理的优点是没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）。

10、什么是虚拟内存？

虚拟内存允许执行进程不必完全在内存中。虚拟内存的基本思想是：每个进程拥有独立的地址空间，这个空间被分为大小相等的多个块，称为页(Page)，每个页都是一段连续的地址。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当程序引用到一部分在物理内存中的地址空间时，由硬件立刻进行必要的映射；当程序引用到一部分不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的命令。这样，对于进程而言，逻辑上似乎有很大的内存空间，实际上其中一部分对应物理内存上的一块(称为帧，通常页和帧大小相等)，还有一些没加载在内存中的对应在硬盘上
注意，请求分页系统、请求分段系统和请求段页式系统都是针对虚拟内存的，通过请求实现内存与外存的信息置换。

虚拟内存实际上可以比物理内存大。当访问虚拟内存时，会访问MMU（内存管理单元）去匹配对应的物理地址（比如图5的0，1，2）。如果虚拟内存的页并不存在于物理内存中（如图5的3,4），会产生缺页中断，从磁盘中取得缺的页放入内存，如果内存已满，还会根据某种算法将磁盘中的页换出。

4). 虚拟内存的应用与优点

虚拟内存很适合在多道程序设计系统中使用，许多程序的片段同时保存在内存中。当一个程序等待它的一部分读入内存时，可以把CPU交给另一个进程使用。虚拟内存的使用可以带来以下好处：

- 在内存中可以保留多个进程，系统并发度提高

- 解除了用户与内存之间的紧密约束，进程可以比内存的全部空间还大

11、内存抖动

指频繁的页调度行为，具体来讲，进程发生缺页中断，这时，必须置换某一页。然而，其他所有的页都在使用，它置换一个页，但又立刻再次需要这个页。因此，会不断产生缺页中断，导致整个系统的效率急剧下降，这种现象称为内存抖动。

内存抖动的解决策略包括：

- 如果是因为页面替换策略失误，可以修改替换算法来解决这个问题；

- 如果是因为运行的程序太多，造成程序无法同时将所有频繁访问的页面调入内存，则要降低多道程序的数量；

- 终止该进程或增加物理内存容量。

### 页面置换算法

在进程运行时，若索要访问的页面不在内存，需把它们从磁盘中调入内存，但内存已无空闲空间时，为了保证该进程能正常运行，系统需从内存中调出一页程序或数据送到磁盘的对换区，而页面置换算法就是用来决定那哪一页被调出的。

**最佳置换（OPT）：** 所选择的要淘汰的页面是在未来最长时间内不会被访问的页面，假设内存被页面a与b占满，此时新调入的页面需要将a与b之一调出，最佳置换算法能预测到页面a将在未来第10次页面访问时才需调入，而页面b将在未来第100次页面访问时才需调入，因此将淘汰b。

**先进先出（FIFO）：** 将内存中的页面排成一个队列，每次无空闲空间时就把队头页面调回外存，将新调入的页面追加到队尾。

**最近最久未使用（LRU）：** 淘汰最近最久未被访问的页面，它为每个页面都设置一个访问计时字段，用来记录一个页面自上次被访问至今所尽力的时间t，当需要淘汰一个页面时就将现有页面中t值最大的淘汰。

**Clock置换：** 采用循环队列存储页面，为页面设置访问位，当某页被访问时，它的访问位被置1。当需要淘汰一页时，只需从队头开始，依次检查页的访问位，如果是0直接淘汰，如果是1则将之置0，若遍历到队尾仍没找到要淘汰的页，则返回队头重复上述操作。

