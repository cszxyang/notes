### 1. olycode

#### 遇到什么样的并发问题？多条线程调用 System.out.println 会出现数据混乱的情况吗

不会，println 调用的是 newLine() 方法，其中使用 synchronized 锁住 PrintStream 对象，尽管 JDK1.6 引入如适应性自旋（Adaptive Spinning）、锁消除（Lock Elimination）、锁粗化（Lock Coarsening）、轻量锁（Lightweight Locking）和偏向锁（Biased Locking）等锁优化技术，但我想着同步等待还是一个比较耗时的操作，为什么不把 I/O 对象线程私有化呢？

为了避免客户端都执行这段代码，多线程竞争和等待同一把锁，去掉了 synchronized，使用ThreadLocal

out 是 System 中持有的一个 PrintStream 类型的常量，我先创建一个叫做 ThreadLocalPrintStream 的 PrintStream 子类，其中的 out 对象是一个ThreadLocal 类型的包裹着 ByteArrayOutputStream 的对象，然后我们可以把 System 拷贝一份其中的 out 对象创建时指定为 ThreadLocalPrintStream 



使用 Future 要获取结果时，需要调用 get 方法，它是阻塞的。	

CompletableFuture 可以设置回调函数，当任务完成时执行某些指定的操作。

#### AST 分析怎么做的

`tools.jar` 中提供了 Java Compiler Tree API，通过这些 API 可以获取到 Java 源代码被语法分析阶段得到抽象语法树 AST，有了 AST 就可以在编译器进行一些语法上的预检查，我的做法是

1. 定义 AbstractProcessor 的实现类，覆盖它的 init 和 procecss 方法，在 proess 方法中获取到语法树节点集合，通过访问器模式将这些节点交给一个 TreePathScanner 实现类处理，在这个访问器中，覆盖父类中定义的访问循环元素节点的方法，对于这些方法，在其前面插入时间声明，实现的效果就是一个 for 循环前面插入一段`long t1 = System.currentTimeMillis()` 这样的代码，同样，在本循环内的最后一条语句后面，挂上超时判断，实现的效果是插入一段形如 `if (System.currentTimeMillis() - time > 3000) throw new LoopTimedOutException("");` 的代码。
2. 将 AbstractProcessor  实现类注册到编译器的编译任务中去

另外，不知道您是否了解 lombok 的实现，我们使用 lombok 时，比如说可以在类声明上加上一个 @Data 注解，就能省掉写 getter、setter 和其他一些方法的麻烦，这里不得不提 JSR269，在此之前，我们定义的注解上的标记`@Retention` 必须为 `RetentionPolicy.RUNTIME`

- 注册一些注解处理器，这些处理器都继承自 AbstractProcessor，通过上面的思路，获取成员声明，然后根据这些成员生成相应的 getter 和 setter 方法，再将这些方法插入到语法树中去。

#### 代理模式

##### 什么是动态代理

个人理解，动态代理就是通过某种技术，在运行时生成某个目标对象的代理对象，并通过一定形式的代码能够使得调用者对目标对象的方法调用透明地重定向到代理对象的方法上去。

##### JDK 代理和 cglib 的区别

JDK 代理：利用拦截器(拦截器必须实现 InvocationHanlder 加上反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用 InvokeHandler 来处理。

cglib：利用 ASM 开源包，对代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。

区别

- **JDK 动态代理只能对实现了接口的类生成代理，而不能针对类。**
- **CGLIB 是针对类实现代理，主要是对指定的类生成一个子类，覆盖其中的方法，并覆盖其中方法实现增强，但是因为采用的是继承，所以该类或方法最好不要声明成 final，对于 final 类或方法，是无法继承的。**

##### 何时使用 JDK 还是 CGLIB？

- 如果目标对象实现了接口，默认情况下会采用JDK的动态代理实现AOP。
- 如果目标对象实现了接口，可以强制使用CGLIB实现AOP。
- 如果目标对象没有实现了接口，必须采用CGLIB库，Spring会自动在JDK动态代理和CGLIB之间转换。

#### 怎么操纵字节码的？

字节码文件具有明确的格式规范，如魔数、主版本号、次版本号、常量池、接口信息等结构及其所占用的字节数。

#### 怎么定义类加载器的？类加载过程是怎么样的？

类加载指的是虚拟机把描述类的数据从字节码文件加载待内存中，并对数据进行校验、转换解析和初始化，最终形成可被虚拟机直接使用的 Java 类型的过程。

![img](D:/projects/notes/面试总结/Java/assets/1551162638264.png)


包括了加载、验证、准备、解析、初始化这五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则是确定的，它在某些情况下，比如说，如果要实现动态绑定（如向上转型，动态绑定到子类的方法），解析会初始化阶段之后开始。

**加载**：查找并加载类的二进制数据，在这个阶段，虚拟机需要完成三件事情：

1. 通过一个类的全限定名来获取其定义的二进制字节流。

2. 根据Java虚拟机规范定义的字节码存储结构格式，将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的`java.lang.Class`对象，作为对方法区中这些数据的访问入口。

加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在内存中（并未明确规定在 Java 堆中，**对 HotSpot VM 而言，Class对象较为特殊，不存储在堆，而存储在方法区中**）创建一个`java.lang.Class`类的对象，这样便可以通过该对象访问方法区中的这些数据。

**验证**：为了确保字节码文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机的安全。 JVM 需要对字节码文件进行验证，验证的对象主要有：字节码文件格式、字节码中元数据定义、字节码中的指令逻辑以及符号引用。

**准备**：为类变量在`方法区`分配内存并`设置类变量默认初始值`。

**解析**：将常量池内的符号引用替换为直接引用，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行。符号引用是一组符号来描述目标，可以是任何字面量。直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。

#### 什么是双亲委派模型？

类加载阶段分为加载、连接、初始化三个阶段，而加载阶段需要通过类的全限定名来获取定义了此类的二进制字节流。**Java 特意把这一步抽出来用类加载器来实现**。

类加载器除了能用来加载类，还能用来作为类的层次划分。Java自身提供了3种类加载器

1. 启动类加载器(Bootstrap ClassLoader),它是属于虚拟机自身的一部分，用C++实现的，主要负责加载`\lib`目录中或被-Xbootclasspath指定的路径中的并且文件名是被虚拟机识别的文件。它等于是所有类加载器的爸爸。

2. 扩展类加载器(Extension ClassLoader),它是 Java 实现的，独立于虚拟机，主要负责加载`\lib\ext`目录中或被 java.ext.dirs 系统变量所指定的路径的类库。

3. 应用程序类加载器(Application ClassLoader),它是Java实现的，独立于虚拟机。主要负责加载用户类路径(classPath)上的类库，如果我们没有实现自定义的类加载器那这玩意就是我们程序中的默认加载器。

![img](https://user-gold-cdn.xitu.io/2019/5/6/16a8d30870f9a8e5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)双亲委派的意思是如果一个类加载器需要加载类，那么首先它会把这个类请求委派给父类加载器去完成，每一层都是如此。一直递归到顶层，当父加载器无法完成这个请求时，子类才会尝试去加载。这里的双亲其实就指的是父类，没有mother。父类也不是我们平日所说的那种继承关系，只是调用逻辑是这样。

#### ThreadLocal 怎么用的？

### 2. SHN 实习

#### 怎么解决慢查的？

首先这是一个搜索功能，正式服数据有 8 千多万，单表查询用了20 多秒。 首先，我定位到实际运行的 SQL 语句，通过 expain 获取其执行计划。

我看到那条 SQL 使用了 order by id DESC，即通查询按主键降序排列。

但执行计划显示其使用的是某个非主键字段的索引，而不是主键索引，同时执行计划中的 extra 列显示的是 using fielsort，即全表扫描，

通过查找资料分析，我认为是在 where 后面没有使用 主键 id 作为条件，虽然 where 后面有些字段是加了索引的，但是在后面降序排列时，由于没有指定 id 条件，所以 MySQL 分析器最后选择了全表扫描。

我的解决方法是改为按照一个加了索引非主键字段进行排序，这个字段是必传的，同时会出现在 where 中。