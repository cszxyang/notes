### 查询优化

- 对频繁查询列建立索引
- 将唯一索引列设置为非空，避免索引失效



### 索引

### 索引的种类？

从语法上有：

- 主键索引 PRIMARY KEY：它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引
- 唯一索引 UNIQUE：唯一索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。可以在创建表的时候指定，也可以修改表结构。
- 普通索引 INDEX：这是最基本的索引，它没有任何限制。可以在创建表的时候指定，也可以修改表结构，

数据机构上有

- B+树索引
- 哈希索引

#### 为什么使用B+树？

优化查询的数据结构还有哈希表、完全平衡二叉树、

- 哈希表：可以快速精确查询，但由于数据并非有序存储，不支持范围查找
- 完全平衡二叉树：支持范围查找，但由于一个结点只能存储一个元素，所以比B+树需要更多的 IO 次数
- B树：比完全二叉平衡树要矮胖，只需少量 IO 就能读取到数据
- B+树：上层结点的数据冗余到叶子中，且叶子结点间存在指针相连，具有更高的范围查找的效率

#### B+树索引的查询类型

- 全值匹配 
  和索引中的所有列进行匹配
- 范围查找

- 匹配最左前缀 
  从最左开始匹配，如果一直满足索引的顺序则可以使用到相关索引，如果在某个位置开始不满足，那么从这个位置开始就用不到索引了

### B+树索引的限制

- 如果不从最左列开始查找，则无法使用到索引

- 如果查询中有某个列的范围查询，则其右边的列都无法使用索引优化查找

#### 索引什么时候失效？

- 单列唯一索引：索引列为空
- 多列唯一索引：只要存在一个索引字段为空，则索引无效

#### 哈希索引

- 只有精确匹配索引的所有列的查询才有效

- 在MySQL中只有Memory引擎显式支持哈希索引 
  （如果多个行哈希值相同，索引会以链表的方式存放多个记录指针到同一个哈希条目中）

- 实现原理：

- 1. 为每个行计算按照索引列计算一个哈希值，这个哈希值和指向该行的指针构成键值对储存

- 1. 哈希值都是有序的，按顺序插入槽中

- 1. 查找：使用索引列计算记录哈希值，拿它去槽中找对应的哈希值，就可以找到对应记录的指针了

### 存储引擎

大概有七个：InnoDB、MyISAM、Archive、Memory、CSV、黑洞

- InnoDB：在MySQL5.5之后成为默认的存储引擎，它的特点有
  - 支持ACID事务
  - 支持行级锁
  - 默认的事务隔离级别是可重复读
  - InnoDB 内部做了很多优化，包括从磁盘读取数据时采用的可预测性预读，能够自动在内存中创建哈希索引以加速读操作的自适应哈希索引(adaptive hash index)，以及能够加速插入操作的插入缓冲区(insert buffer)等。
  - 支持热备份，即备份数据时不用停止对表的读写操作。
- MyISAM：
  - 仅支持表级锁，封锁时系统开销低，但并发度也小
  - 能够对表进行自动执行检査和修复，但修复操作不仅慢而且可能会丢失数据
  - 对于不再修改的表，可以对表进行压缩存储，读取时支持按行解压
- Archive：
    - 支持行级锁
    - 会对插入数据进行压缩
    - 设有专用的缓冲区，支持批量插入
- Memory：
  - 表结构存储在磁盘，但表数据都存储在内存，重启后表结构还在，但表数据会丢失    
  - 查询更快
  - 支持哈希索引
  - 仅支持表级锁
  - 用于保存数据分析的中间结果

### 事务

事务是数据库的逻辑工作单位，是恢复和并发的基本单位，具有ACID特性。

#### ACID

- 原子性（Atomicity）：对于事务中的所有操作，要么都做，要么都不做。
- 一致性（Consistency）：一致性是由由原子性保障的，因为事务处于成功提交的状态称为一致性状态，事务提交要么成功，要么失败回滚到上一个成功的状态。
- 隔离性（Isolation）：不同事务的内部操作及其使用的数据彼此隔离，互不干扰。
- 持续性（Durability）：事务一旦提交成功，它对数据库中的数据的改变是永久性的，接下来的其他操作和故障不会影响它的执行结果。

####  隔离级别

- 脏读：事务A读取数据d，同时事务B修改了数据d，事务A能直接看到事务B对数据d的修改，但是如果事务B回滚，事务A看到的数据是脏数据，即不正确的数据。
- 不可重读读：事务A读取数据d，同时事务B修改了数据d，在事务B提交之前，事务A看不到事务B对数据d的修改。但是在事务B提交之后，事务A读取到的数据d的值与原来的不一致。
- 幻影读：事务A读取数据集d，事务B在d中增加或删除一些记录，事务A再次读取数据集d的时候，发现多了或者少了一些数据。

| 事务隔离级别                 | 脏读 | 不可重复读 | 幻读 |
| ---------------------------- | ---- | ---------- | ---- |
| 读未提交（read-uncommitted） | 是   | 是         | 是   |
| 不可重复读（read-committed） | 否   | 是         | 是   |
| 可重复读（repeatable-read）  | 否   | 否         | 是   |
| 串行化（serializable）       | 否   | 否         | 否   |

- **读未提交（read-uncommitted）：**事务A读取数据d，同时事务B修改了数据d，事务A能直接看到事务B对数据d的修改，但是如果事务B回滚，事务A看到的数据时脏数据，即不正确的数据。
- **不可重复读（read-committed）：**使用行级锁，在该隔离级别下，比如说事务A读取数据d，同时事务B修改了数据d，在事务B提交之前，事务A看不到事务B对数据d的修改。但是在事务B提交之后，事务A读取到的数据d的值与原来的不一致，即不可重复读。
- **可重复读（repeatable-read）：**如果检索条件有索引（包括主键索引）的时候，默认加锁方式是next-key锁；如果检索条件没有索引，更新数据时会锁住整张表。一个间隙被事务加了锁，其他事务是不能在这个间隙插入记录的，这样可以防止幻读。InnoDB默认的隔离级别。
- **串行化（serializable）：**采用表级锁，并发性极低

**隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大**

### 封锁

三种锁：

- 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。
- 页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般
- 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。

#### 乐观锁和悲观锁

悲观锁具有强烈的独占性和排他性，在数据处理的时候，将数据处于锁定状态，在事务的提交之前（提交之后释放事务过程中的锁），外界无法修改这些数据，依赖于数据库提供的锁机制

乐观锁机制则是采取了更加宽松的加锁机制，避免了加锁开销，

悲观锁保证了操作的最大独占性，但是随之而来的是数据库性能的大量开销，尤其是长事务。乐观锁是基于数据版本记录机制实现，在数据库表中增加一个version字段，更新时，读取版本号，然后提交时版本号+1，但是提交的数据版本号须大于数据库表当前数据库表版本号，予以更新，否则认为是过期数据

在实现上，可以通过设置版本号字段实现乐观锁，可以在支持事务的存储引擎上通过`select...for update`实现悲观锁。

#### SQL注入

由于传入的参数与系统的SQL拼接成了合法的SQL而导致的，而其本质还是将用户输入的数据当做了代码执行。

- 对输入做格式限制，如登录时的name或者password不允许带有%之类的符号
- 使用网络应用防火墙（WAF），过滤异常流量
- 尽量使用预编译SQL语句

#### 安全部署

强密码、最小特权原则

### 主从复制



### 安全